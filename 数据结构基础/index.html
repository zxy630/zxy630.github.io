<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zxy630.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="必背知识点&amp;易错填空题 数据的逻辑结构可分为线性与非线性 数据的物理结构可分为顺序与非顺序 存储数据时，不仅要存储数据元素的值，还要存储数据元素之间的关系 描述数据的逻辑结构的方式是定义抽象数据类型 四种基本的数据结构是集合、线性表、树、图">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构基础">
<meta property="og:url" content="https://zxy630.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="小粥同学的博客">
<meta property="og:description" content="必背知识点&amp;易错填空题 数据的逻辑结构可分为线性与非线性 数据的物理结构可分为顺序与非顺序 存储数据时，不仅要存储数据元素的值，还要存储数据元素之间的关系 描述数据的逻辑结构的方式是定义抽象数据类型 四种基本的数据结构是集合、线性表、树、图">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-25T08:15:05.000Z">
<meta property="article:author" content="小粥同学">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zxy630.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://zxy630.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/","path":"数据结构基础/","title":"数据结构基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构基础 | 小粥同学的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小粥同学的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9-amp-%E6%98%93%E9%94%99%E5%A1%AB%E7%A9%BA%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">必背知识点&amp;易错填空题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.1.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.2.</span> <span class="nav-text">满二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.3.</span> <span class="nav-text">完全二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.4.</span> <span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.5.</span> <span class="nav-text">链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">二叉树的遍历（递归）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">先序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.3.</span> <span class="nav-text">后序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88%E4%BD%BF%E7%94%A8%E5%A0%86%E6%A0%88%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">二叉树的非递归遍历（使用堆栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">先序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.3.4.</span> <span class="nav-text">层序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9"><span class="nav-number">2.4.</span> <span class="nav-text">输出二叉树中的所有叶子结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="nav-number">2.5.</span> <span class="nav-text">求二叉树的高度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86"><span class="nav-number">2.6.</span> <span class="nav-text">二元运算表达式及其遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B1%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.7.</span> <span class="nav-text">由两种遍历序列确定二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%89BST"><span class="nav-number">2.8.</span> <span class="nav-text">二叉搜索树（二叉查找树、二叉排序树）BST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BST%E7%89%B9%E7%82%B9"><span class="nav-number">2.9.</span> <span class="nav-text">BST特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C%EF%BC%9AFind"><span class="nav-number">2.9.1.</span> <span class="nav-text">查找操作：Find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="nav-number">2.9.2.</span> <span class="nav-text">查找最大和最小元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-number">2.9.3.</span> <span class="nav-text">二叉搜索树的插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">2.9.4.</span> <span class="nav-text">二叉搜索树的删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BABST"><span class="nav-number">2.9.5.</span> <span class="nav-text">判断是否为BST</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95Huffman"><span class="nav-number">2.10.</span> <span class="nav-text">哈夫曼算法Huffman</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%BC%96%E7%A0%81"><span class="nav-number">2.11.</span> <span class="nav-text">前缀编码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">3.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.</span> <span class="nav-text">堆的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E8%B0%83%E6%95%B4"><span class="nav-number">3.2.</span> <span class="nav-text">堆调整</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E9%83%A8%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4"><span class="nav-number">3.2.1.</span> <span class="nav-text">顶部向下调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E9%83%A8%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4"><span class="nav-number">3.2.2.</span> <span class="nav-text">尾部向上调整</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A0%86"><span class="nav-number">3.3.</span> <span class="nav-text">创建堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">4.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%9B%BE"><span class="nav-number">4.1.</span> <span class="nav-text">遍历图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2DFS"><span class="nav-number">4.1.1.</span> <span class="nav-text">深度优先搜索DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2BFS"><span class="nav-number">4.1.2.</span> <span class="nav-text">广度优先搜索BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">4.2.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95Prim"><span class="nav-number">4.2.1.</span> <span class="nav-text">普里姆算法Prim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95Kruskal"><span class="nav-number">4.2.2.</span> <span class="nav-text">克鲁斯卡尔算法Kruskal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">4.3.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95Dijkstra"><span class="nav-number">4.3.1.</span> <span class="nav-text">迪杰斯特拉算法Dijkstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95Floyd"><span class="nav-number">4.3.2.</span> <span class="nav-text">弗洛伊德算法Floyd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bellman-Ford%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E8%B4%9F%E6%9D%83%E8%BE%B9"><span class="nav-number">4.3.3.</span> <span class="nav-text">Bellman-Ford——解决负权边</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BEDAG"><span class="nav-number">4.4.</span> <span class="nav-text">有向无环图DAG</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8FTopological-Sort"><span class="nav-number">4.4.1.</span> <span class="nav-text">拓扑排序Topological Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84Critical-Path"><span class="nav-number">4.4.2.</span> <span class="nav-text">关键路径Critical Path</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubble-Sort"><span class="nav-number">5.1.</span> <span class="nav-text">冒泡排序Bubble Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsert-Sort"><span class="nav-number">5.2.</span> <span class="nav-text">插入排序Insert Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelect-Sort"><span class="nav-number">5.3.</span> <span class="nav-text">选择排序Select Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8FShell-Sort"><span class="nav-number">5.4.</span> <span class="nav-text">希尔排序Shell Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8FMerge-Sort"><span class="nav-number">5.5.</span> <span class="nav-text">归并排序Merge Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuick-Sort"><span class="nav-number">5.6.</span> <span class="nav-text">快速排序Quick Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8FHeap-Sort"><span class="nav-number">5.7.</span> <span class="nav-text">堆排序Heap Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8FRadix-Sort"><span class="nav-number">5.8.</span> <span class="nav-text">基数排序Radix Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8FBucket-Sort"><span class="nav-number">5.9.</span> <span class="nav-text">桶排序Bucket Sort</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">小粥同学</p>
  <div class="site-description" itemprop="description">勇敢自信乐观努力的宇宙无敌大可爱</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zxy630.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小粥同学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小粥同学的博客">
      <meta itemprop="description" content="勇敢自信乐观努力的宇宙无敌大可爱">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构基础 | 小粥同学的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-25 16:15:05" itemprop="dateCreated datePublished" datetime="2022-06-25T16:15:05+08:00">2022-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-03-20 10:47:50" itemprop="dateModified" datetime="2024-03-20T10:47:50+08:00">2024-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="必背知识点-amp-易错填空题"><a href="#必背知识点-amp-易错填空题" class="headerlink" title="必背知识点&amp;易错填空题"></a>必背知识点&amp;易错填空题</h1><ol>
<li>数据的逻辑结构可分为<u>线性与非线性</u></li>
<li>数据的物理结构可分为<u>顺序与非顺序</u></li>
<li>存储数据时，不仅要存储数据元素的值，还要<u>存储数据元素之间的关系</u></li>
<li>描述数据的逻辑结构的方式是<u>定义抽象数据类型</u></li>
<li>四种基本的数据结构是<u>集合、线性表、树、图</u><span id="more"></span></li>
<li>数据结构中，与所使用的的计算机无关的是<u>数据的逻辑结构</u></li>
<li>研究数据结构的三个方面：<u>逻辑结构、存储结构、运算</u></li>
<li>单链表中，增加头结点的目的是<u>方便运算的实现</u></li>
<li>循环链表的主要优点是<u>从表中任意结点出发都能扫描到整个链表</u></li>
<li>算法分析的两个主要方面：<u>时间复杂度、空间复杂度</u></li>
<li>线性表是具有n个<u>数据元素</u>的有限序列</li>
<li>线性表中的每个结点都有且仅有一个直接前驱和后继<u>(×)</u>要考虑首尾</li>
<li>一个长度为n的顺序表中删除第i个元素，需要向前移动<u>n-i</u>个元素</li>
<li>链表具备的特点：<u>不必事先估计存储空间，所需空间与其长度成正比，插入删除不需要移动元素</u></li>
<li>带头结点的单链表L为空的判定条件是<u>L-&gt;next &#x3D;&#x3D; NULL</u></li>
<li>某线性表用带头结点的循环单链表存储，头指针为head，当head-&gt;next-&gt;next-&gt;next &#x3D; head成立时，线性表的长度为<u>0或2</u>（头结点不算长度）</li>
<li>循环链表的主要优点是<u>从表中的任意结点出发都能扫描到整个链表</u></li>
<li>静态链表与动态链表相比，其缺点是<u>有可能浪费较多的存储空间</u>，因为静态链表已经开辟了一段空间</li>
<li>与单链表相比，双链表的优点之一是<u>访问前后相邻结点更灵活</u></li>
<li>能在o(1)时间内访问线性表的第i个元素的结构是<u>顺序表</u>，顺序表直接以i为下标标志访问</li>
<li>对于一个线性表，既要求较快地进行插入删除，又要求存储结构能够反映数据元素之间的逻辑关系，则应采用<u>链式存储结构</u></li>
<li>若某线性表最常用的操作时存取任一指定序号的元素和在最后插入删除，则利用<u>顺序表</u>存储方式最省时间</li>
<li>设一个链表最常用的操作是在末尾插入和删除结点，则选用<u>带头结点的双循环链表</u></li>
<li>长度为n的<u>只有首结点指针h的不带头结点的循环单链表</u>删除第一个元素，其算法的时间复杂度为o(n)，因为得把尾巴接上去</li>
<li>算法分析的主要任务是<u>分析算法的执行时间和问题规模之间的关系</u></li>
<li>算法分析的目的是<u>分析算法的效率以求改进</u></li>
<li>某算法的时间复杂度是o($n^2$)，表明该算法的<u>执行时间与$n^2$成正比</u></li>
<li>顺序栈中，判断栈s为空的条件是：<u>s.top &#x3D;&#x3D; s.base</u></li>
<li>顺序栈中，判断栈满的条件是：<u>s.top - s.base &gt;&#x3D; s.stacksize</u></li>
<li>top &#x3D;&#x3D; N表示栈空，向栈插入一个元素时，首先应执行语句top–</li>
<li>链栈与顺序栈相比有一明显优点，即<u>通常不会出现栈满现象</u></li>
<li>大小为6的数组实现循环队列，且当前rear和front的值分别为0,3，当从队列中删除一个元素再加入两个元素后rear&#x3D;<u>2</u>，front&#x3D;<u>4</u>。因为删除时front+1，加入时rear+1</li>
<li>栈的操作原则：<u>后进先出</u>；last in first out</li>
<li>函数调用时，处理参数及返回地址需要用一种<u>栈</u>的数据结构</li>
<li>中缀表达式(A+B)<em>(C-D)&#x2F;(E-F</em>G)的后缀表达式是<u>AB+CD-乘EFG乘-&#x2F;</u></li>
<li>n个元素进栈序列是p1,p2,…,pn，其输出序列是1,2,…,n，若pn&#x3D;1，则pi&#x3D;<u>n-i+1</u></li>
<li>a+b-a*((c+d)&#x2F;e-f)+g转换为等价的后缀表达式，用栈来存放暂时还不能确定运算次数的操作符，若栈初始为空，则保存在栈中操作符的最大个数为<u>5</u></li>
<li>入栈序列为abcdefg，出栈序列为bdcfega，则栈的容量至少为<u>3</u></li>
<li>一棵二叉树的度可以小于2，因为二叉树的定义是每个结点的度不超过2</li>
<li>具有10个叶结点的二叉树中有<u>9</u>个度为2的结点，因为$n_0 &#x3D; n_2 + 1$</li>
<li>线性表是一种逻辑结构，线性链表是一种物理结构，表示用链表实现线性表</li>
<li>算法的5个重要特性：<ul>
<li>有穷性：有穷步、有穷时间内完成</li>
<li>确定性：不会产生二义性</li>
<li>可行性：有限次</li>
<li>输入：0个或多个</li>
<li>输出：1个或多个</li>
</ul>
</li>
<li>好的算法的追求目标：正确性、可读性、健壮性（容错性、try except）、效率与低存储量要求</li>
<li>常用的时间复杂度：1 &lt; $logn$ &lt; $n$ &lt; $nlogn$ &lt; $n^2$ &lt; $n^3$ &lt; $2^n$ &lt; $n!$ &lt; $n^n$</li>
<li>满二叉树(k层共$2^k-1$个结点)与完全二叉树(n个结点共$log_2n$ + 1 层)：<ul>
<li>最多只有1个度为1的结点；</li>
<li>左子树的高度&#x3D;右子树的高度(+1)</li>
<li>均可用顺势存储</li>
</ul>
</li>
<li>一棵完全二叉树第5层有6个叶结点，则该完全二叉树的结点最多是<u>51</u>个，最少是<u>21</u>个<ul>
<li>$2^5 - 1 + (2^4 - 6) * 2 &#x3D; 51$ </li>
<li>$2^4 - 1 + 6 &#x3D; 21$</li>
</ul>
</li>
<li>完全二叉树求两个结点最近的双亲，谁大谁除以2，直到相等结束，就是逐层上推的过程</li>
<li>森林中有n个非终端结点，则对应的二叉树中右指针域为空的结点有$n+1$个（每个非终端结点下的孩子必然有1个右指针域为空的 + 根结点）</li>
<li>哈夫曼树算法：找两个最小的不断向上合并，也叫最优二叉树，$WPL &#x3D; \frac{\sum_{k&#x3D;1}^{n}w_k}{k}$</li>
<li>图是由顶点和边构成，顶点是有穷非空集合，故没有空图的概念，而树有空树的概念</li>
<li>连通图——无向图；强连通图——有向图</li>
<li>n个顶点确保是连通图的边数为$\frac{(n-1)(n-2)}{2} + 1$，其中n-1个顶点强连通+一条边连第n个顶点</li>
<li>n个顶点的连通分量数是[1,n]</li>
</ol>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>不包含回路的连通无向图</p>
<ul>
<li>一棵树中的任意两个结点有且仅有唯一的一条路径连通</li>
<li>一棵树如果有n个结点，那么它一定恰好友n-1条边</li>
<li>在一棵树中加一条边会构成一个回路</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个结点最多有两个儿子</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>一棵深度为h且有$2^h-1$个结点的二叉树</p>
<p>每个内部结点都有两个儿子的二叉树</p>
<p>所有叶结点都有同样的深度的二叉树</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>若二叉树的高度为h，除第h层外，其他各层的结点数都达到最大个数，第h层从右往左连续缺若干结点</p>
<p>如果一个结点有右孩子，那么一定有左孩子</p>
<p>一棵二叉树除了最右边位置上有一个或者几个叶结点缺少外，其他是丰满的</p>
<p>满二叉树和完全二叉树都可以用一维数组存储，且父亲与孩子之间有2倍的关系</p>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>一般是用来存完全二叉树：从左至右，从上至下存储</p>
<ul>
<li>非根结点(i&gt;0)的父结点是[i&#x2F;2]</li>
<li>结点i的左孩子结点序号是2i，右孩子的是2i+1</li>
</ul>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TNode* BinTree; // 树指针</span><br><span class="line">typedef struct TNode&#123;</span><br><span class="line">    ElementTypr data; // 数据</span><br><span class="line">    BinTree left; // 左孩子</span><br><span class="line">    BinTree right; //右孩子</span><br><span class="line">&#125; *Position;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的遍历（递归）"><a href="#二叉树的遍历（递归）" class="headerlink" title="二叉树的遍历（递归）"></a>二叉树的遍历（递归）</h2><p>三种遍历过程中经过结点的路线是一样的，只是访问的时机不同</p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void PreOrderTraverse(BinTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;left);</span><br><span class="line">        PreOrderTraverse(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void MidOrderTraverse(BinTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        MidOrderTraverse(T-&gt;left);</span><br><span class="line">        printf(&quot;%d&quot;,T-&gt;data);</span><br><span class="line">        MidOrderTraverse(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void PostOrderTraverse(BinTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        PostOrderTraverse(T-&gt;left);</span><br><span class="line">        PostOrderTraverse(T-&gt;right);</span><br><span class="line">        printf(&quot;%d&quot;,T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的非递归遍历（使用堆栈）"><a href="#二叉树的非递归遍历（使用堆栈）" class="headerlink" title="二叉树的非递归遍历（使用堆栈）"></a>二叉树的非递归遍历（使用堆栈）</h2><h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void PreOrderTraverse(BinTree T)&#123;</span><br><span class="line">    stack s = createStack(MaxSize);</span><br><span class="line">    while(T || !IsEmpty(s))&#123;</span><br><span class="line">        while(T)&#123; // 往左压栈</span><br><span class="line">            push(s,T);</span><br><span class="line">            printf(&quot;%d&quot;,T-&gt;data);</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!IsEmpty(s))&#123; // 弹出时把右指针压栈</span><br><span class="line">            T = pop(s);</span><br><span class="line">            T = T-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void MidOrderTraverse(BinTree T)&#123;</span><br><span class="line">    stack s = createStack(MaxSize);</span><br><span class="line">    while(T || !IsEmpty(s))&#123;</span><br><span class="line">        while(T)&#123; // 往左压栈</span><br><span class="line">            push(s,T);</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!IsEmpty(s))&#123; // 弹出时把右指针压栈</span><br><span class="line">            T = pop(s);</span><br><span class="line">            printf(&quot;%d&quot;,T-&gt;data);</span><br><span class="line">            T = T-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>在pop时做判断，如果当前结点存在右子树则需要将其在此压栈，若不存在右子树，则直接输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void PostOrderTraverse(BinTree T)&#123;</span><br><span class="line">    stack s = createStack(MaxSize);</span><br><span class="line">    BinTree temp = NULL; // 保存上次弹出的元素</span><br><span class="line">    while(T || !IsEmpty(s))&#123;</span><br><span class="line">        while(T)&#123; // 往左压栈</span><br><span class="line">            push(s,T);</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!IsEmpty(s))&#123; // 弹出时把右指针压栈</span><br><span class="line">            T = pop(s);</span><br><span class="line">            if(T-&gt;right == NULL || T-&gt;right == temp)&#123;</span><br><span class="line">                printf(&quot;%d&quot;,T-&gt;data);</span><br><span class="line">                temp = T;</span><br><span class="line">                T = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                push(s,T);</span><br><span class="line">                T = T-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>从根开始遍历，将根入队，开始循环：结点出队、访问、其左右儿子入队</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void levelOrderTraverse(BinTree T)&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    if(!T) return;</span><br><span class="line">    Q = createQueue(maxSize);</span><br><span class="line">    addQ(Q,T);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        T = deleteQ(Q);</span><br><span class="line">        printf(T-&gt;data);</span><br><span class="line">        if(T-&gt;left) addQ(Q,T-&gt;left);</span><br><span class="line">        if(T-&gt;right) addQ(Q,T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出二叉树中的所有叶子结点"><a href="#输出二叉树中的所有叶子结点" class="headerlink" title="输出二叉树中的所有叶子结点"></a>输出二叉树中的所有叶子结点</h2><p>只需在遍历输出中增加检测结点的左右子树是否都为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrderTraverse(BinTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        if(!T-&gt;left &amp;&amp; !T-&gt;right)</span><br><span class="line">            printf(&quot;%d&quot;,T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;left);</span><br><span class="line">        PreOrderTraverse(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h2><p>递归求法：树的高度 &#x3D; 左右子树的最大高度 + 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int getHeight(BinTree T)&#123;</span><br><span class="line">    int HL,HR,maxH;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        HL = getHeight(T-&gt;left);</span><br><span class="line">        HR = getHeight(T-&gt;right);</span><br><span class="line">        maxH = (HL &gt; HR):HL?HR;</span><br><span class="line">        return maxH + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; // 空树高度为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二元运算表达式及其遍历"><a href="#二元运算表达式及其遍历" class="headerlink" title="二元运算表达式及其遍历"></a>二元运算表达式及其遍历</h2><p>表达式树的结点：叶结点为运算数，非叶结点为运算符</p>
<ul>
<li>先序遍历——前缀表达式</li>
<li>中序遍历——中缀表达式（受运算符优先级的影响，可在输出左子树时先加个(，左子树结束时再加个)）</li>
<li>后续遍历——后缀表达式</li>
</ul>
<h2 id="由两种遍历序列确定二叉树"><a href="#由两种遍历序列确定二叉树" class="headerlink" title="由两种遍历序列确定二叉树"></a>由两种遍历序列确定二叉树</h2><p>两种之一必有中序序列。</p>
<p>如已知先序和中序序列求树的步骤：</p>
<ol>
<li>根据先序遍历第一个结点确定根结点</li>
<li>根据根结点在中序序列中的位置分割成左右两个子序列</li>
<li>对左右子树递归使用相同的方法分解</li>
</ol>
<h2 id="二叉搜索树（二叉查找树、二叉排序树）BST"><a href="#二叉搜索树（二叉查找树、二叉排序树）BST" class="headerlink" title="二叉搜索树（二叉查找树、二叉排序树）BST"></a>二叉搜索树（二叉查找树、二叉排序树）BST</h2><ol>
<li>非空左子树的所有键值≤其根结点的键值</li>
<li>非空右子树的所有键值≥其根结点的键值</li>
<li>左右子树都是BST</li>
</ol>
<h2 id="BST特点"><a href="#BST特点" class="headerlink" title="BST特点"></a>BST特点</h2><ul>
<li>左≤中≤右</li>
<li>新结点总是作为叶子结点来插入</li>
<li>中序遍历可得有序序列</li>
</ul>
<h3 id="查找操作：Find"><a href="#查找操作：Find" class="headerlink" title="查找操作：Find"></a>查找操作：Find</h3><ol>
<li>查找从根结点开始，若树为空，返回NULL</li>
<li>若树非空，根结点关键字和x作比较<ul>
<li>若x&lt;根键值，则搜索左子树</li>
<li>若x&gt;根键值，则搜索右子树</li>
<li>若x&#x3D;根键值，搜索完成，返回指向此结点指针</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Position Find(ElementType x,BinTree T)&#123;</span><br><span class="line">    if(!T) return NULL;</span><br><span class="line">    if(x &gt; T-&gt;data)&#123;</span><br><span class="line">        return Find(x,T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(x &lt; T-&gt;data)&#123;</span><br><span class="line">        return Find(x,T-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    else return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找最大和最小元素"><a href="#查找最大和最小元素" class="headerlink" title="查找最大和最小元素"></a>查找最大和最小元素</h3><p>最大一定在最右分支的端结点上，最小一定在最左分支的端结点上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Position FindMin(BinTree T)&#123;</span><br><span class="line">    if(!T) return NULL;</span><br><span class="line">    else if(!T-&gt;left) return T;</span><br><span class="line">    else return FindMin(T-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注】：若一棵BST是一个有n个结点的完全二叉树，则该树的最大值一定是在叶结点上(×)，可能是在根上的左斜树，则该树的最小值一定是在叶结点上(√)</p>
<h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BinTree Insert(ElementType x,BinTree T)&#123;</span><br><span class="line">    if(!T)&#123;</span><br><span class="line">        T = malloc(sizeof(struct TNode));</span><br><span class="line">        T-&gt;data = x;</span><br><span class="line">        T-&gt;left = T-&gt;right = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(x &lt; T-&gt;data)&#123;</span><br><span class="line">            T-&gt;left = Insert(x,T-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(x &gt; T-&gt;data)&#123;</span><br><span class="line">            T-&gt;right = Insert(x,T-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><ol>
<li>要删除的为叶结点：直接删除，并修改其父结点指向为NULL</li>
<li>要删除的结点只有一个孩子结点：将其父节点的指针指向要删除结点的孩子结点</li>
<li>要删除的结点有左右两棵子树，用右子树的最小结点<strong>或</strong>左子树的最大结点替换被删除结点</li>
</ol>
<h3 id="判断是否为BST"><a href="#判断是否为BST" class="headerlink" title="判断是否为BST"></a>判断是否为BST</h3><p>中序遍历，若得到序列递增，则为BST</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int IsBST(BinTree T)&#123;</span><br><span class="line">    int left,right;</span><br><span class="line">    if(!T) return 1; // 空树也是BST，直接返回1</span><br><span class="line">    else&#123;</span><br><span class="line">        left = IsBST(T-&gt;left);</span><br><span class="line">        if(left == 0 || pre &gt;= T-&gt;data) return 0;</span><br><span class="line">        pre = T-&gt;data; //保存当前结点的值</span><br><span class="line">        right = IsBST(T-&gt;right);</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼算法Huffman"><a href="#哈夫曼算法Huffman" class="headerlink" title="哈夫曼算法Huffman"></a>哈夫曼算法Huffman</h2><ol>
<li>从序列中依次找到两个最小元素a和b作为左孩子和右孩子建立二叉树结点c；</li>
<li>从原序列中删除a和b，并在原序列尾插入c；</li>
<li>重复(1)(2)直到序列中只剩下一棵树，即为哈夫曼树。</li>
</ol>
<ul>
<li>编码：从根到叶子</li>
<li>解码：从叶子到根</li>
<li>n个叶子，则共2n-1个结点</li>
<li>没有度为1的结点</li>
</ul>
<h2 id="前缀编码"><a href="#前缀编码" class="headerlink" title="前缀编码"></a>前缀编码</h2><p>设计长短不等的编码，必须任一字符的编码都不是另一个字符编码的前缀，这种编码称为前缀编码。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><p>一种特殊的完全二叉树</p>
<h2 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h2><h3 id="顶部向下调整"><a href="#顶部向下调整" class="headerlink" title="顶部向下调整"></a>顶部向下调整</h3><p>和左右孩子比较，与其中最小的交换，直到满足最小堆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 传入一个需要向下调整的结点编号i</span><br><span class="line">void siftdown(int i)&#123;</span><br><span class="line">    int t,flag = 0; // 标记是否需要继续向下调整</span><br><span class="line">    // 当i有儿子（至少是有左儿子）并且有需要继续调整时，循环执行</span><br><span class="line">    while(i*2&lt;=n &amp;&amp; flag == 0)&#123;</span><br><span class="line">        // 首先判断和左儿子的关系，并用t记录值较小的结点编号</span><br><span class="line">        if(h[i] &gt; h[i*2])&#123;</span><br><span class="line">            t = i * 2;</span><br><span class="line">        &#125;</span><br><span class="line">        else t = i;</span><br><span class="line">        // 如果有右儿子，再对右儿子进行讨论</span><br><span class="line">        if(i*2+1 &lt;= n)&#123;</span><br><span class="line">            if(h[t] &gt; h[i*2+1])</span><br><span class="line">                t = i*2+1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果发现最小的结点编号不是自己，说明子节点中有比父节点更小的</span><br><span class="line">        if(t != i)&#123;</span><br><span class="line">            swap(t,i); // 交换位置</span><br><span class="line">            i = t; // 更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            flag = 1; // 父节点已比当前两个子节点都小，不用继续调整了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尾部向上调整"><a href="#尾部向上调整" class="headerlink" title="尾部向上调整"></a>尾部向上调整</h3><p>&#x2F;&#x2F; 如父结点更大，则与其交换，直到满足最小堆特性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 传入一个需要向上调整的结点编号i</span><br><span class="line">void siftup(int i)&#123;</span><br><span class="line">    int flag = 0; // 标记是否需要继续向下调整</span><br><span class="line">    if(i == 0) return; // 已经是堆顶，不需要调整</span><br><span class="line">    // 不在堆顶，并且有需要继续调整时，循环执行</span><br><span class="line">    while(i!=0 &amp;&amp; flag == 0)&#123;</span><br><span class="line">        // 判断是否比父结点小</span><br><span class="line">        if(h[i] &lt; h[i/2])&#123;</span><br><span class="line">            swap(i/2,i); // 交换位置</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            flag = 1; // 父节点已比当前两个子节点都小，不用继续调整了</span><br><span class="line">        &#125;</span><br><span class="line">        i = i/2; // 更新编号为父结点的编号，继续向上调整</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建堆"><a href="#创建堆" class="headerlink" title="创建堆"></a>创建堆</h2><p>把n个元素建立一个堆，首先将n个结点以自顶向下，从左到右的方式从1到n编码，转换成一棵完全二叉树，紧接着从最后一个非叶结点(n&#x2F;2)到根结点(0)，逐个扫描，根据需要将其向下调整，直到根结点的子树符合堆的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i = n/2; i &gt;= 0; i--)&#123;</span><br><span class="line">    siftdown(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="遍历图"><a href="#遍历图" class="headerlink" title="遍历图"></a>遍历图</h2><h3 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h3><p>不撞南墙不回头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int step)&#123;</span><br><span class="line">    判断边界，到达边界直接返回</span><br><span class="line">    // 尝试每一种可能</span><br><span class="line">    for(int i = 1; i &lt; n; i++ )&#123;</span><br><span class="line">        // 继续下一步</span><br><span class="line">        dfs(step + 1);</span><br><span class="line">        // 在搜索完毕后可能需要做一些清除操作，意味着每回退一步要把上一步的标记清除</span><br><span class="line">    &#125;</span><br><span class="line">    返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 设图采用邻接表存储结构，递归实现深度搜索</span><br><span class="line"></span><br><span class="line">/* Visited[]为全局变量，已经初始化为false */</span><br><span class="line">void DFS( LGraph Graph, Vertex v)</span><br><span class="line">&#123;   /* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */</span><br><span class="line">    int W;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%s&quot;,G.vertices[v].data);  /* 访问第V个顶点 */</span><br><span class="line">    Visited[v] = true; /* 标记V已访问 */</span><br><span class="line"></span><br><span class="line">    for(w = FirstAdjVex(G,v); w &gt; 0; w = NextAdjVex(G,v,w))// 对v的每个邻接点</span><br><span class="line">        if ( !Visited[w-&gt;AdjV] )    /* 若W-&gt;AdjV未被访问 */</span><br><span class="line">            DFS( Graph, w-&gt;AdjV);    /* 则递归访问之 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h3><p>层层递进</p>
<p>利用队列保存待访问的结点，访问每个结点时将其邻接顶点加入队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 设图采用邻接表存储结构，队列实现广度搜索</span><br><span class="line">void BFSTraverse(ALGraph G)</span><br><span class="line">&#123;</span><br><span class="line">    int v,u,w;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    for(v  = 0; v &lt;G.vexnum; v++)&#123;</span><br><span class="line">        // 将visited数组初始化为FALSE</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(Q); // 初始化空队列</span><br><span class="line">    for(v = 0; v &lt; G.vexnum; v++)&#123; // 逐个访问顶点</span><br><span class="line">        if(!visited[v])&#123;</span><br><span class="line">            visited[v] = TRUE; // 修改访问标志</span><br><span class="line">            printf(&quot;%s&quot;,G.vertices[v].data); // 打印输出</span><br><span class="line">            EnQueue(Q,v); // 入队</span><br><span class="line">            while(!EmptyQueue(Q))&#123; // 取队头并将其所有邻接点访问入队</span><br><span class="line">                DeQueue(Q,u);</span><br><span class="line">                for(w = FirstAdjVex(G,u); w &gt; 0; w = NextAdjVex(G,u,w))&#123;</span><br><span class="line">                    if(!visited[w])&#123;</span><br><span class="line">                        visited[w] = TURE;</span><br><span class="line">                        printf(&quot;%s&quot;,G.vertices[w].data);</span><br><span class="line">                        EnQueue(Q,w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普里姆算法Prim"><a href="#普里姆算法Prim" class="headerlink" title="普里姆算法Prim"></a>普里姆算法Prim</h3><p>逐渐连通整张图：选择到达的顶点中代价最小的，逐渐加入所有顶点，故适合边稠密的图</p>
<ol>
<li>把起点加入集合U；</li>
<li>找集合U中的元素到集合V-U中的元素的代价最小边（借助closedge数组）到达的结点，加入集合U；</li>
<li>重复(2)执行n-1轮，得到最小生成树。</li>
</ol>
<h3 id="克鲁斯卡尔算法Kruskal"><a href="#克鲁斯卡尔算法Kruskal" class="headerlink" title="克鲁斯卡尔算法Kruskal"></a>克鲁斯卡尔算法Kruskal</h3><p>避圈法：将连通分量逐渐合并，选择代价最小的边，且不构成回路，逐渐加入边涵盖所有顶点，故适合边稀疏的图</p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><table>
<thead>
<tr>
<th></th>
<th>Floyd</th>
<th>Dijkstra</th>
<th>Bellman-Ford</th>
<th>带队列优化的Bellman-Ford</th>
</tr>
</thead>
<tbody><tr>
<td>空间复杂度</td>
<td>O($N^2$)</td>
<td>O($M$)</td>
<td>O($M$)</td>
<td>O($M$)</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O($N^3$)</td>
<td>O($(M+N)logN$)</td>
<td>O($NM$)</td>
<td>最坏也是O($NM$)</td>
</tr>
<tr>
<td>适用情况</td>
<td>稠密图<br>和顶点关系密切</td>
<td>稠密图<br>和顶点关系密切</td>
<td>稀疏图<br>和边关系密切</td>
<td>稀疏图<br>和边关系密切</td>
</tr>
<tr>
<td>负权</td>
<td>可以解决</td>
<td>不能解决</td>
<td>可以解决</td>
<td>可以解决</td>
</tr>
<tr>
<td>判定是否存在负权回路</td>
<td>不能</td>
<td>不能</td>
<td>可以</td>
<td>可以</td>
</tr>
</tbody></table>
<h3 id="迪杰斯特拉算法Dijkstra"><a href="#迪杰斯特拉算法Dijkstra" class="headerlink" title="迪杰斯特拉算法Dijkstra"></a>迪杰斯特拉算法Dijkstra</h3><p>Dijkstra算法算是贪心思想实现的，首先把起点到所有点的距离存下来找个最短的，然后<strong>松弛</strong>一次再找出最短的。</p>
<p>所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。</p>
<p>计算某一点到其他所有结点的最短路径。</p>
<blockquote>
<p>Dijkstra不能解决带有负权边（边的权值为负数）的图。</p>
</blockquote>
<blockquote>
<p>一种基于贪心策略的算法，每次新扩展一个路程最短的点，更新与其相邻的点的路程。当所有边权都为正时，由于不会存在一个路程更短的没扩展过的点，所以这个点的路程永远不会再被改变，因而保证了算法的正确性。不过根据这个原理，用本算法求最短路径的图是不能有负权边的，因为扩展到负权边的时候会产生更短的路程，有可能就破坏了已经更新的点路径不能改变的性质。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; n-1; i++)&#123;</span><br><span class="line">    // 找距离该顶点最近的顶点</span><br><span class="line">    min = inf;</span><br><span class="line">    for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">        if(book[j] == 0 &amp;&amp; dis[j] &lt; min)&#123;</span><br><span class="line">            min = dis[j];</span><br><span class="line">            u = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    book[u] = 1;</span><br><span class="line">    for(int v = 0; v &lt; n; v++)&#123;</span><br><span class="line">        if(e[u][v] &lt; inf)&#123;</span><br><span class="line">            if(dis[v] &gt; dis[u] + e[u][v])&#123; // 动态方程</span><br><span class="line">                dis[v] = dis[u] + e[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="弗洛伊德算法Floyd"><a href="#弗洛伊德算法Floyd" class="headerlink" title="弗洛伊德算法Floyd"></a>弗洛伊德算法Floyd</h3><p>Floyd算法的核心思想是动态规划，一次计算所有点对的最短路径，时间复杂度为O($n^3$)，其步骤可大致描述为：</p>
<ol>
<li>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</li>
<li>对于每一对顶点u和v，看看是否存在一个顶点w使得从u到w再到v比已知的路径更短。如果是更新它。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int k = 0; k &lt; n; k++)&#123;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            if(e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">                e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bellman-Ford——解决负权边"><a href="#Bellman-Ford——解决负权边" class="headerlink" title="Bellman-Ford——解决负权边"></a>Bellman-Ford——解决负权边</h3><p>以边为中转进行松弛：一共进行n-1轮，进行第k轮，即求的顶点“最多经过k条边”到达其余各顶点的最短路径长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// n表示顶点个数，m表示边个数</span><br><span class="line">for(int k = 0; k &lt; n-1; k++)&#123; // 进行n-1轮松弛</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123; // 枚举每一条边</span><br><span class="line">        if(dis[v[i]] &gt; dis[u[i]] + w[i])&#123;</span><br><span class="line">            dis[v[i]] = dis[u[i]] + w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果进行n-1轮松弛后，动态方程仍成立，说明此图存在负权回路</p>
<h2 id="有向无环图DAG"><a href="#有向无环图DAG" class="headerlink" title="有向无环图DAG"></a>有向无环图DAG</h2><h3 id="拓扑排序Topological-Sort"><a href="#拓扑排序Topological-Sort" class="headerlink" title="拓扑排序Topological Sort"></a>拓扑排序Topological Sort</h3><ol>
<li>选择一个入度为0的顶点并输出之；</li>
<li>从图中删除此顶点及出边；</li>
<li>重复(1)(2)，直到不存在入度为0的顶点，此时判断已输出顶点数是否与原有顶点相等，如果不等则出现回路。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接表存储 - 拓扑排序算法 */</span><br><span class="line"></span><br><span class="line">bool TopSort( LGraph Graph, Vertex TopOrder[] )</span><br><span class="line">&#123; /* 对Graph进行拓扑排序,  TopOrder[]顺序存储排序后的顶点下标 */</span><br><span class="line">    int Indegree[MaxVertexNum], cnt;</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">       Queue Q = CreateQueue( Graph-&gt;Nv );</span><br><span class="line"> </span><br><span class="line">    /* 初始化Indegree[] */</span><br><span class="line">    for (V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        Indegree[V] = 0;</span><br><span class="line">        </span><br><span class="line">    /* 遍历图，得到Indegree[] */</span><br><span class="line">    for (V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        for (W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next)</span><br><span class="line">            Indegree[W-&gt;AdjV]++; /* 对有向边&lt;V, W-&gt;AdjV&gt;累计终点的入度 */</span><br><span class="line">            </span><br><span class="line">    /* 将所有入度为0的顶点入列 */</span><br><span class="line">    for (V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        if ( Indegree[V]==0 )</span><br><span class="line">            AddQ(Q, V);</span><br><span class="line">            </span><br><span class="line">    /* 下面进入拓扑排序 */ </span><br><span class="line">    cnt = 0; </span><br><span class="line">    while( !IsEmpty(Q) )&#123;</span><br><span class="line">        V = DeleteQ(Q); /* 弹出一个入度为0的顶点 */</span><br><span class="line">        TopOrder[cnt++] = V; /* 将之存为结果序列的下一个元素 */</span><br><span class="line">        /* 对V的每个邻接点W-&gt;AdjV */</span><br><span class="line">        for ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next )</span><br><span class="line">            if ( --Indegree[W-&gt;AdjV] == 0 )/* 若删除V使得W-&gt;AdjV入度为0 */</span><br><span class="line">                AddQ(Q, W-&gt;AdjV); /* 则该顶点入列 */ </span><br><span class="line">    &#125; /* while结束*/</span><br><span class="line">    </span><br><span class="line">    if ( cnt != Graph-&gt;Nv )</span><br><span class="line">        return false; /* 说明图中有回路, 返回不成功标志 */ </span><br><span class="line">    else</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键路径Critical-Path"><a href="#关键路径Critical-Path" class="headerlink" title="关键路径Critical Path"></a>关键路径Critical Path</h3><p>AOV网：有向无环图，优先考虑顶点</p>
<p>AOE网：带权的有向无环图，优先考虑边</p>
<p>AOE网只是比AOV网多了一个边的权重，而且AOV网一般关注各个子工程实施的先后顺序，而AOE网就是不仅仅关注子工程的实施的先后顺序，同时也关系整个工程完成最短时间。</p>
<p>关键路径：AOE-网中，从起点到终点最长的路径的长度（长度指的是路径上边的权重和）</p>
<p>关键活动：关键路径上的边</p>
<ol>
<li>所有关键活动都提前完成，才会提前整个工程的完成时间。</li>
<li>关键活动组成了关键路径，关键路径是图中的最长路径，关键路径长度代表整个工期的最短完成时间，关键活动延期完成，必将导致关键路径长度增加，即整个工期的最短完成时间增加。</li>
<li>键路径并不唯一，当有多条关键路径存在时，其中一条关键路径上的关键活动时间缩短，只能导致本条关键路径变成非关键路径，而无法缩短整个工期，因为其他关键路径没有变化。</li>
</ol>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O($n^{4&#x2F;3}$)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O($nlogn$)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O($nlogn$)</td>
<td>O(logn)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O($nlogn$)</td>
<td>O(n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O($d(n+r)$)</td>
<td>O(n+r)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O($n+m$)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h2 id="冒泡排序Bubble-Sort"><a href="#冒泡排序Bubble-Sort" class="headerlink" title="冒泡排序Bubble Sort"></a>冒泡排序Bubble Sort</h2><p>按一个方向扫描，每次比较<strong>两个相邻</strong>的元素，如果它们的顺序错误就把它们交换过来。</p>
<p>每将一个数归位我们将其称为“一趟”，每一趟只能确定将一个数归位。</p>
<p>如果有n个数进行排序，只需将n-1个数归位，也就是说要进行n-1趟操作。而“每一趟”都需要从第0位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，知道<strong>最后一个尚未归位的数</strong>，已经归位的数无需再进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Bubble_Sort(int num[n])&#123;</span><br><span class="line">    for(int i = 0; i &lt; n - 1; i++)&#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int j = 0; j &lt; n - i; j++)&#123;</span><br><span class="line">            if(num[j] &gt; num[j+1])&#123;</span><br><span class="line">                swap(num[j],num[j+1]);</span><br><span class="line">                flag = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag == 0) break;// 一趟无交换，则按序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序Insert-Sort"><a href="#插入排序Insert-Sort" class="headerlink" title="插入排序Insert Sort"></a>插入排序Insert Sort</h2><p>首位哨兵，来一个往前比较到合适位置插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Insert_Sort(int num[n])&#123;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        int tmp = num[i]; // 待插入</span><br><span class="line">        for(int j = i; j &gt; 0 &amp;&amp; num[j-1] &gt; tmp; j--)&#123;</span><br><span class="line">            num[j] = num[j-1]; // 移出空位</span><br><span class="line">        &#125;</span><br><span class="line">        num[j] = tmp; // 按序插入</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序Select-Sort"><a href="#选择排序Select-Sort" class="headerlink" title="选择排序Select Sort"></a>选择排序Select Sort</h2><p>循环n次，每次从当前到后面挑一个最小的排，不稳定，可能被交换到后面。如果快速找到最小的可以利用堆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Select_Sort(int num[n])&#123;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        int minPosition = ScanForMin(num,i,n); // 从后面找到最小的</span><br><span class="line">        swap(num[i],num[minPosition]); // 将其放在当前位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序Shell-Sort"><a href="#希尔排序Shell-Sort" class="headerlink" title="希尔排序Shell Sort"></a>希尔排序Shell Sort</h2><p>定义增量序列$D_k$，对每个增量进行间隔排序，若增量不互质，则小增量可能根本不起作用，故增量序列一般满足$D_k &#x3D; 2^k - 1$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Shell_Sort(int num[n])&#123;</span><br><span class="line">    for(int gap = n/2; gap &gt; 0; gap /= 2)&#123; // 每次增量减半</span><br><span class="line">        for(int i = gap; i &lt; n; i++)&#123;</span><br><span class="line">            int tmp = num[i]; // 待排序元素</span><br><span class="line">            for(int j = i; j &gt;= 0 &amp;&amp; num[j-gap] &gt; tmp; j -= gap)&#123;</span><br><span class="line">                num[j] = num[j-gap]; // 元素向后移动</span><br><span class="line">            &#125;</span><br><span class="line">            num[j] = gap; // 插入待排序元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序Merge-Sort"><a href="#归并排序Merge-Sort" class="headerlink" title="归并排序Merge Sort"></a>归并排序Merge Sort</h2><p>有序子列的归并，逐渐合成完整的有序列。但是归并不能在原数组上操作，递归合并时开辟临时数组，故空间复杂度为O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Merge_Sort(int num[n],int result[n],int L,int R,int RightEnd)&#123;</span><br><span class="line">    int LeftEnd = R-1;</span><br><span class="line">    int tmp = L;</span><br><span class="line">    countElements = RightEnd - L + 1; // 元素总个数</span><br><span class="line">    while(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)&#123; // 按序归并</span><br><span class="line">        if(num[L] &lt;= num[R]) result[tmp++] = num[L++];</span><br><span class="line">        else result[tmp++] = num[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 把剩余的装入，实际只有一个while会被执行</span><br><span class="line">    while(L &lt;= LeftEnd)&#123;</span><br><span class="line">        result[tmp++] = num[L++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(R &lt;= RightENd)&#123;</span><br><span class="line">        result[tmp++] = num[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 将结果返回装入num</span><br><span class="line">    for(int i = 0; i &lt; countElements; i++, RightEnd--)&#123;</span><br><span class="line">        num[RightEnd] = result[RightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序Quick-Sort"><a href="#快速排序Quick-Sort" class="headerlink" title="快速排序Quick Sort"></a>快速排序Quick Sort</h2><p>利用<strong>枢纽</strong>分而治之，以最左为枢纽，从后找比枢纽小的，从前找比枢纽大的，都找到后做交换，直到相遇了交换完毕，把枢纽放过去，故枢纽每次都是最终位置，确保了前面的都比它小，后面的都比它大。</p>
<p>每一轮处理都让这一轮的枢纽归位，每次交换都是跳跃式的，这样总的比较和交换次数就少了，速度就提高了，但最坏情况仍可能为相邻交换O($n^2$)，但平均时间复杂度为O(nlogn)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void Quick_Sort(int left,int right)&#123;</span><br><span class="line">	if(left &gt; right) return;</span><br><span class="line">	// 枢纽 </span><br><span class="line">	int pivot = num[left];</span><br><span class="line">	</span><br><span class="line">	int i = left;</span><br><span class="line">	int j = right;</span><br><span class="line">	while(i != j)&#123;</span><br><span class="line">		// 左边为枢纽，一定要先从右开始动 </span><br><span class="line">		while(num[j] &gt;= pivot &amp;&amp; i &lt; j)&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		while(num[i] &lt;= pivot &amp;&amp; i &lt; j)&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		// 交换两个哨兵数 </span><br><span class="line">		if(i &lt; j)&#123;</span><br><span class="line">			int temp = num[i];</span><br><span class="line">			num[i] = num[j];</span><br><span class="line">			num[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 交换完毕后能确保ij指向同一位置即枢纽该在的位置 </span><br><span class="line">	num[left] = num[i];</span><br><span class="line">	num[i] = pivot;</span><br><span class="line">	// 递归去处理前后半段 </span><br><span class="line">	Quick_Sort(left,i-1);</span><br><span class="line">	Quick_Sort(i+1,right);</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 用C语言自带的函数qsort，只需要写好标准形式cmp</span><br><span class="line">int cmp_int(const void* _a, const void* _b)&#123;</span><br><span class="line">    int* a = (int*) _a;</span><br><span class="line">    int* b = (int*) _b;</span><br><span class="line">    return *a - *b;</span><br><span class="line">&#125;</span><br><span class="line">qsort(num,len(num),sizeof(num[0]),cmp_int);</span><br></pre></td></tr></table></figure>
<h2 id="堆排序Heap-Sort"><a href="#堆排序Heap-Sort" class="headerlink" title="堆排序Heap Sort"></a>堆排序Heap Sort</h2><p>需要O(n)额外空间先将数组建成最小堆，每次从堆中取头为最小，删除后重新调整堆。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 删除最小的元素并调整</span><br><span class="line">int DeleteMin(Heap h)&#123;</span><br><span class="line">    int t;</span><br><span class="line">    t = h[1];</span><br><span class="line">    h[1] = h[n]; // 首尾互换</span><br><span class="line">    n --; // 堆的元素减少1</span><br><span class="line">    siftdown(0); // 将堆顶向下调整</span><br><span class="line">    return t; // 堆顶为最小值返回</span><br><span class="line">&#125;</span><br><span class="line">void Heap_Sort(int num[n])&#123;</span><br><span class="line">    Heap h = BuildHeap(num);</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        num[i] = DeleteMin(h); // 每次找最小并删除调整</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序Radix-Sort"><a href="#基数排序Radix-Sort" class="headerlink" title="基数排序Radix Sort"></a>基数排序Radix Sort</h2><p>将各基数看做桶，通过链表串联</p>
<h2 id="桶排序Bucket-Sort"><a href="#桶排序Bucket-Sort" class="headerlink" title="桶排序Bucket Sort"></a>桶排序Bucket Sort</h2><p>需要知道数据的变化范围，设置相应的桶，往对应的桶里丢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Bucket_Sort(int num[n])&#123;</span><br><span class="line">    int count[m]; // 初始化,m为数据的变化范围</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        count[num[i]]对应的链表加入num[i]</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        if(count[i])&#123;</span><br><span class="line">            输出链表对应的元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;// 时间复杂度O(m+n) 空间复杂度O(m)</span><br></pre></td></tr></table></figure>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"># 计算机基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E8%AF%BB%E3%80%8A%E5%85%8B%E6%8B%89%E6%8B%89%E4%B8%8E%E5%A4%AA%E9%98%B3%E3%80%8B%E6%9C%89%E6%84%9F/" rel="prev" title="读《克拉拉与太阳》有感">
                  <i class="fa fa-angle-left"></i> 读《克拉拉与太阳》有感
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/welcome/" rel="next" title="欢迎">
                  欢迎 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">小粥同学</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
